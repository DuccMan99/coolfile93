/* opcodes_ed.c: Z80 CBxx opcodes
   Copyright (c) 1999-2008 Philip Kendall, Matthew Westcott

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    Contact details: <matthew@west.co.tt>
    Matthew Westcott, 14 Daisy Hill Drive, Adlington, Chorley, Lancs PR6 9NE UNITED KINGDOM

*/

/* NB: this file is autogenerated by 'z80.pl' from 'opcodes_ed.dat',
   and included in 'z80_ops.jscpp' */

    ops[0x40] = function op_0x40(tempaddr) {		/* IN B,(C) */
      tstates += 1;
      IN(B,BCR);
    };
    ops[0x41] = function op_0x41(tempaddr) {		/* OUT (C),B */
      tstates += 1;
      OUT(BCR,B);
    };
    ops[0x42] = function op_0x42(tempaddr) {		/* SBC HL,BC */
      tstates += 7;
      SBC16(BCR);
    };
    ops[0x43] = function op_0x43(tempaddr) {		/* LD (nnnn),BC */
      LD16_NNRR(C,B);
    };
    ops[0x44] = 
    ops[0x4c] = 
    ops[0x54] = 
    ops[0x5c] = 
    ops[0x64] = 
    ops[0x6c] = 
    ops[0x74] = 
    ops[0x7c] = function op_0x7c(tempaddr) {		/* NEG */
      {
    var bytetemp=A;
    A=0;
    SUB(bytetemp);
      }
    };
    ops[0x45] = 
    ops[0x4d] = 
    ops[0x55] = 
    ops[0x5d] = 
    ops[0x65] = 
    ops[0x6d] = 
    ops[0x75] = 
    ops[0x7d] = function op_0x7d(tempaddr) {		/* RETN */
      IFF1=IFF2;
      RET();
    };
    ops[0x46] = 
    ops[0x4e] = 
    ops[0x66] = 
    ops[0x6e] = function op_0x6e(tempaddr) {		/* IM 0 */
      IM=0;
    };
    ops[0x47] = function op_0x47(tempaddr) {		/* LD I,A */
      tstates += 1;
      I=A;
    };
    ops[0x48] = function op_0x48(tempaddr) {		/* IN C,(C) */
      tstates += 1;
      IN(C,BCR);
    };
    ops[0x49] = function op_0x49(tempaddr) {		/* OUT (C),C */
      tstates += 1;
      OUT(BCR,C);
    };
    ops[0x4a] = function op_0x4a(tempaddr) {		/* ADC HL,BC */
      tstates += 7;
      ADC16(BCR);
    };
    ops[0x4b] = function op_0x4b(tempaddr) {		/* LD BC,(nnnn) */
      LD16_RRNN(C,B);
    };
    ops[0x4f] = function op_0x4f(tempaddr) {		/* LD R,A */
      tstates += 1;
      /* Keep the RZX instruction counter right */
      /* rzx_instructions_offset += ( R - A ); */
      R=R7=A;
    };
    ops[0x50] = function op_0x50(tempaddr) {		/* IN D,(C) */
      tstates += 1;
      IN(D,BCR);
    };
    ops[0x51] = function op_0x51(tempaddr) {		/* OUT (C),D */
      tstates += 1;
      OUT(BCR,D);
    };
    ops[0x52] = function op_0x52(tempaddr) {		/* SBC HL,DE */
      tstates += 7;
      SBC16(DER);
    };
    ops[0x53] = function op_0x53(tempaddr) {		/* LD (nnnn),DE */
      LD16_NNRR(E,D);
    };
    ops[0x56] = 
    ops[0x76] = function op_0x76(tempaddr) {		/* IM 1 */
      IM=1;
    };
    ops[0x57] = function op_0x57(tempaddr) {		/* LD A,I */
      tstates += 1;
      A=I;
      F = ( F & FLAG_C ) | sz53_table[A] | ( IFF2 ? FLAG_V : 0 );
    };
    ops[0x58] = function op_0x58(tempaddr) {		/* IN E,(C) */
      tstates += 1;
      IN(E,BCR);
    };
    ops[0x59] = function op_0x59(tempaddr) {		/* OUT (C),E */
      tstates += 1;
      OUT(BCR,E);
    };
    ops[0x5a] = function op_0x5a(tempaddr) {		/* ADC HL,DE */
      tstates += 7;
      ADC16(DER);
    };
    ops[0x5b] = function op_0x5b(tempaddr) {		/* LD DE,(nnnn) */
      LD16_RRNN(E,D);
    };
    ops[0x5e] = 
    ops[0x7e] = function op_0x7e(tempaddr) {		/* IM 2 */
      IM=2;
    };
    ops[0x5f] = function op_0x5f(tempaddr) {		/* LD A,R */
      tstates += 1;
      A=(R&0x7f) | (R7&0x80);
      F = ( F & FLAG_C ) | sz53_table[A] | ( IFF2 ? FLAG_V : 0 );
    };
    ops[0x60] = function op_0x60(tempaddr) {		/* IN H,(C) */
      tstates += 1;
      IN(H,BCR);
    };
    ops[0x61] = function op_0x61(tempaddr) {		/* OUT (C),H */
      tstates += 1;
      OUT(BCR,H);
    };
    ops[0x62] = function op_0x62(tempaddr) {		/* SBC HL,HL */
      tstates += 7;
      SBC16(HLR);
    };
    ops[0x63] = function op_0x63(tempaddr) {		/* LD (nnnn),HL */
      LD16_NNRR(L,H);
    };
    ops[0x67] = function op_0x67(tempaddr) {		/* RRD */
      {
    var bytetemp = readbyte( HLR );
    tstates+=10;
    writebyte(HLR,  ( (A & 0x0f) << 4 ) | ( bytetemp >> 4 ) );
    A = ( A & 0xf0 ) | ( bytetemp & 0x0f );
    F = ( F & FLAG_C ) | sz53p_table[A];
      }
    };
    ops[0x68] = function op_0x68(tempaddr) {		/* IN L,(C) */
      tstates += 1;
      IN(L,BCR);
    };
    ops[0x69] = function op_0x69(tempaddr) {		/* OUT (C),L */
      tstates += 1;
      OUT(BCR,L);
    };
    ops[0x6a] = function op_0x6a(tempaddr) {		/* ADC HL,HL */
      tstates += 7;
      ADC16(HLR);
    };
    ops[0x6b] = function op_0x6b(tempaddr) {		/* LD HL,(nnnn) */
      LD16_RRNN(L,H);
    };
    ops[0x6f] = function op_0x6f(tempaddr) {		/* RLD */
      {
    var bytetemp = readbyte( HLR );
    tstates+=10;
    writebyte(HLR, ((bytetemp & 0x0f) << 4 ) | ( A & 0x0f ) );
    A = ( A & 0xf0 ) | ( bytetemp >> 4 );
    F = ( F & FLAG_C ) | sz53p_table[A];
      }
    };
    ops[0x70] = function op_0x70(tempaddr) {		/* IN F,(C) */
      tstates += 1;
      {
    var bytetemp;
    IN(bytetemp,BCR);
      }
    };
    ops[0x71] = function op_0x71(tempaddr) {		/* OUT (C),0 */
      tstates += 1;
      OUT(BCR,0);
    };
    ops[0x72] = function op_0x72(tempaddr) {		/* SBC HL,SP */
      tstates += 7;
      SBC16(SPR);
    };
    ops[0x73] = function op_0x73(tempaddr) {		/* LD (nnnn),SP */
      LD16_NNRR(SPLR,SPHR);
    };
    ops[0x78] = function op_0x78(tempaddr) {		/* IN A,(C) */
      tstates += 1;
      IN(A,BCR);
    };
    ops[0x79] = function op_0x79(tempaddr) {		/* OUT (C),A */
      tstates += 1;
      OUT(BCR,A);
    };
    ops[0x7a] = function op_0x7a(tempaddr) {		/* ADC HL,SP */
      tstates += 7;
      ADC16(SPR);
    };
    ops[0x7b] = function op_0x7b(tempaddr) {		/* LD SP,(nnnn) */
      LD16_RRNNW(SP);
    };
    ops[0xa0] = function op_0xa0(tempaddr) {		/* LDI */
      {
    var bytetemp=readbyte( HLR );
    tstates+=8;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    writebyte(DER,bytetemp);
    var detemp = (DER + 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    
    bytetemp = (bytetemp + A) & 0xff;
    F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
      ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      }
    };
    ops[0xa1] = function op_0xa1(tempaddr) {		/* CPI */
      {
    var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
      lookup = ( (        A & 0x08 ) >> 3 ) |
               ( (  (value) & 0x08 ) >> 2 ) |
               ( ( bytetemp & 0x08 ) >> 1 );
    tstates+=8;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
      halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
      ( bytetemp & FLAG_S );
    if(F & FLAG_H) bytetemp--;
    F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      }
    };
    ops[0xa2] = function op_0xa2(tempaddr) {		/* INI */
      {
    var initemp = readport( BCR );
    tstates += 5; contend_io( BCR, 3 );
    writebyte(HLR,initemp);
    B = (B-1)&0xff;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
      }
    };
    ops[0xa3] = function op_0xa3(tempaddr) {		/* OUTI */
      {
    var outitemp=readbyte( HLR );
    B = (B-1)&0xff;    /* This does happen first, despite what the specs say */
    tstates+=5; contend_io( BCR, 3 );
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    writeport(BCR,outitemp);
    F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
      }
    };
    ops[0xa8] = function op_0xa8(tempaddr) {		/* LDD */
      {
    var bytetemp=readbyte( HLR );
    tstates+=8;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    writebyte(DER,bytetemp);
    var detemp = (DER - 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    
    bytetemp = (bytetemp + A) & 0xff;
    F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
      ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
      }
    };
    ops[0xa9] = function op_0xa9(tempaddr) {		/* CPD */
      {
    var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
      lookup = ( (        A & 0x08 ) >> 3 ) |
               ( (  (value) & 0x08 ) >> 2 ) |
               ( ( bytetemp & 0x08 ) >> 1 );
    tstates+=8;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
      halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
      ( bytetemp & FLAG_S );
    if(F & FLAG_H) bytetemp--;
    F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
      }
    };
    ops[0xaa] = function op_0xaa(tempaddr) {		/* IND */
      {
    var initemp = readport( BCR );
    tstates += 5; contend_io( BCR, 3 );
    writebyte(HLR,initemp);
    B = (B-1)&0xff;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
      }
    };
    ops[0xab] = function op_0xab(tempaddr) {		/* OUTD */
      {
    var outitemp=readbyte( HLR );
    B = (B-1)&0xff;    /* This does happen first, despite what the specs say */
    tstates+=5; contend_io( BCR, 3 );
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    writeport(BCR,outitemp);
    F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
      }
    };
    ops[0xb0] = function op_0xb0(tempaddr) {		/* LDIR */
      {
    var bytetemp=readbyte( HLR );
    tstates+=8;
    writebyte(DER,bytetemp);
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var detemp = (DER + 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    bytetemp = (bytetemp + A) & 0xff;
    F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
      ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
    if(BCR) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xb1] = function op_0xb1(tempaddr) {		/* CPIR */
      {
    var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
      lookup = ( (        A & 0x08 ) >> 3 ) |
           ( (  (value) & 0x08 ) >> 2 ) |
           ( ( bytetemp & 0x08 ) >> 1 );
    tstates+=8;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
      halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
      ( bytetemp & FLAG_S );
    if(F & FLAG_H) bytetemp--;
    F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
    if( ( F & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xb2] = function op_0xb2(tempaddr) {		/* INIR */
      {
    var initemp=readport( BCR );
    tstates += 5; contend_io( BCR, 3 );
    writebyte(HLR,initemp);
    B = (B-1)&0xff;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
    if(B) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xb3] = function op_0xb3(tempaddr) {		/* OTIR */
      {
    var outitemp=readbyte( HLR );
    tstates+=5;
    B = (B-1)&0xff;
    var hltemp = (HLR + 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    /* This does happen first, despite what the specs say */
    writeport(BCR,outitemp);
    F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
    if(B) {
      contend_io( BCR, 1 );
      tstates+=7;
      PC-=2;
    } else {
      contend_io( BCR, 3 );
    }
      }
    };
    ops[0xb8] = function op_0xb8(tempaddr) {		/* LDDR */
      {
    var bytetemp=readbyte( HLR );
    tstates+=8;
    writebyte(DER,bytetemp);
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var detemp = (DER - 1) & 0xffff; D = detemp >> 8; E = detemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    bytetemp = (bytetemp + A) & 0xff;
    F = ( F & ( FLAG_C | FLAG_Z | FLAG_S ) ) | ( BCR ? FLAG_V : 0 ) |
      ( bytetemp & FLAG_3 ) | ( (bytetemp & 0x02) ? FLAG_5 : 0 );
    if(BCR) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xb9] = function op_0xb9(tempaddr) {		/* CPDR */
      {
    var value = readbyte( HLR ), bytetemp = (A - value) & 0xff,
      lookup = ( (        A & 0x08 ) >> 3 ) |
           ( (  (value) & 0x08 ) >> 2 ) |
           ( ( bytetemp & 0x08 ) >> 1 );
    tstates+=8;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    var bctemp = (BCR - 1) & 0xffff; B = bctemp >> 8; C = bctemp & 0xff;
    F = ( F & FLAG_C ) | ( BCR ? ( FLAG_V | FLAG_N ) : FLAG_N ) |
      halfcarry_sub_table[lookup] | ( bytetemp ? 0 : FLAG_Z ) |
      ( bytetemp & FLAG_S );
    if(F & FLAG_H) bytetemp--;
    F |= ( bytetemp & FLAG_3 ) | ( (bytetemp&0x02) ? FLAG_5 : 0 );
    if( ( F & ( FLAG_V | FLAG_Z ) ) == FLAG_V ) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xba] = function op_0xba(tempaddr) {		/* INDR */
      {
    var initemp=readport( BCR );
    tstates += 5; contend_io( BCR, 3 );
    writebyte(HLR,initemp);
    B = (B-1)&0xff;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    F = (initemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
    if(B) {
      tstates+=5;
      PC-=2;
    }
      }
    };
    ops[0xbb] = function op_0xbb(tempaddr) {		/* OTDR */
      {
    var outitemp=readbyte( HLR );
    tstates+=5;
    B = (B-1)&0xff;
    var hltemp = (HLR - 1) & 0xffff; H = hltemp >> 8; L = hltemp & 0xff;
    /* This does happen first, despite what the specs say */
    writeport(BCR,outitemp);
    F = (outitemp & 0x80 ? FLAG_N : 0 ) | sz53_table[B];
    /* C,H and P/V flags not implemented */
    if(B) {
      contend_io( BCR, 1 );
      tstates+=7;
      PC-=2;
    } else {
      contend_io( BCR, 3 );
    }
      }
    };
    ops[256] = function() {};        /* All other opcodes are NOPD */
